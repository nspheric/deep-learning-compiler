import torch
import torch.nn as nn
import torch.fx as fx

# this vgg block was generated by chat gpt
class VGGBlock(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(VGGBlock, self).__init__()
        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1)
        self.relu = nn.ReLU()
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)

    def forward(self, x):
        x = self.conv1(x)
        x = self.relu(x)
        x = self.conv2(x)
        x = self.relu(x)
        x = self.pool(x)
        return x

# this should be enough to do the basic optimizations
class DAG:
    def __init__(self, nodes):
        self.nodes = nodes
    def get_nodes(self):
        return self.nodes
class Node:
    def __init__(self, name, edges):
        self.name = name
        self.edges = edges
    def get_edges(self):
        return self.edges
        

# in a deep learning compiler the deep learning model
# is represented as a dag where the operations such as
# relu and convolution are the nodes and the edges are
# tensors, i.e., weights and bias
def torch_to_dag(model):
    traced_model = fx.symbolic_trace(model)
    nodes = list()
    for node in traced_model.graph.nodes:
        if node.op == 'call_module':
            layer_name = node.target
            layer = getattr(model, layer_name)
            if isinstance(layer, nn.Conv2d):
                weights = layer.weight.data
                bias = layer.bias.data
                edges = list()
                edges.append({"weights": weights})
                edges.append({"bias": bias})
                nodes.append(Node("conv2d", edges))
                
        elif node.op == 'call_function':
            if node.target == nn.functional.relu:
                # not sure what the edges are for relu nodes
                edges = list()
                edges.append({"input_tensor": traced_model.get_node(node.args[0])})
                nodes.append(Node("relu", edges))

    dag = DAG(nodes)
    return dag
                
            

vgg = VGGBlock(in_channels=3, out_channels=64)

print(torch_to_dag(vgg))

dag = torch_to_dag(vgg)

for node in dag.get_nodes():
    print(node.get_edges())
    
